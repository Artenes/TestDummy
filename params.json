{"name":"TestDummy","tagline":"Laughably simple database seeding for integration testing.","body":"# TestDummy [![Build Status](https://travis-ci.org/laracasts/TestDummy.svg?branch=master)](https://travis-ci.org/laracasts/TestDummy)\r\n\r\n![image](https://dl.dropboxusercontent.com/u/774859/GitHub-Repos/testdummy/crashtestdummy.jpg)\r\n\r\nTestDummy makes the process of preparing factories (dummy data) for your integration tests as easy as possible.\r\n\r\nAs easy as...\r\n\r\n### Build a Post model with dummy attributes.\r\n\r\n```php\r\nuse Laracasts\\TestDummy\\Factory;\r\n\r\n$post = Factory::build('Post');\r\n```\r\n\r\nIf we then do `$post->toArray()`, this might return:\r\n\r\n```bash\r\narray(4) {\r\n  [\"title\"]=>\r\n  string(21) \"The Title of the Post\"\r\n  [\"author_id\"]=>\r\n  string(1) \"5\"\r\n  [\"body\"]=>\r\n  string(226) \"Iusto qui optio et iste. Cumque aliquid et omnis enim. Nesciunt ad esse a reiciendis expedita quidem veritatis. Nostrum repellendus reiciendis distinctio amet sapiente. Eum molestias a recusandae modi aut et adipisci corrupti.\"\r\n  [\"publish_date\"]=>\r\n  string(19) \"2014-03-02 11:05:48\"\r\n}\r\n```\r\n\r\n### Build a post, but override the default title.\r\n\r\n```php\r\nuse Laracasts\\TestDummy\\Factory;\r\n\r\n$post = Factory::build('Post', ['title' => 'Override Title']);\r\n```\r\n\r\nAgain, when cast to an array...\r\n\r\n```bash\r\narray(4) {\r\n  [\"title\"]=>\r\n  string(14) \"Override Title\"\r\n  [\"author_id\"]=>\r\n  string(1) \"5\"\r\n  [\"body\"]=>\r\n  string(254) \"In eos porro qui est rerum possimus voluptatem non. Repudiandae eaque nostrum eaque aut deleniti possimus quod minus. Molestiae commodi odit sunt dignissimos corrupti repudiandae quibusdam quo. Autem maxime tenetur autem corporis aut quis sint occaecati.\"\r\n  [\"publish_date\"]=>\r\n  string(19) \"2013-06-24 10:01:30\"\r\n}\r\n```\r\n\r\n### Build an array of attributes for the model.\r\n\r\n```php\r\n$post = Factory::attributesFor('Post');\r\n```\r\n\r\nThe difference between `build()` and `attributesFor()` is that the former will return an instance of the given model type (such as `Post`). The latter will simply return an array of the generated attributes, which can be useful in some situations. \r\n\r\n### Build and persist a song entity.\r\n\r\n```php\r\nuse Laracasts\\TestDummy\\Factory;\r\n\r\n$song = Factory::create('Song');\r\n```\r\n\r\n### Create and persist a comment three times.\r\n\r\n```php\r\nuse Laracasts\\TestDummy\\Factory;\r\n\r\nFactory::times(3)->create('Comment');\r\n```\r\n\r\nIn effect, this will give you three rows in your `comments` table. If that table has relationships (such as an owning Post), those related rows will be created with dummy data as well.\r\n\r\n## Usage\r\n\r\n### Step 1: Install\r\n\r\nPull this package in through Composer, just like any other package.\r\n\r\n```js\r\n\"require-dev\": {\r\n    \"laracasts/testdummy\": \"~2.0\"\r\n}\r\n```\r\n\r\n### Step 2: Create a Factories File\r\n\r\nTestDummy isn't magic. You need to describe the type of data that should be generated.\r\n\r\nWithin a `tests/factories` directory, you may create any number of PHP files that will automatically be\r\nloaded by TestDummy. Why don't you start with a generic `tests/factories/factories.php` file.\r\n\r\nEach factory file you create will automatically have access to two variables:\r\n\r\n- `$factory`\r\n- `$faker`\r\n\r\n`$factory` is the function that you'll use to define new sets of data, such as the makeup of a Post or Album.\r\n\r\n```php\r\n$factory('Album', [\r\n    'name' => 'Rock or Bust',\r\n    'artist' => 'AC/DC'\r\n]);\r\n```\r\n\r\nThink of this as your definition for any future generated albums - like when you do this:\r\n\r\n```php\r\nuse Laracasts\\TestDummy\\Factory;\r\n\r\n$album = Factory::create('Album');\r\n```\r\n\r\n#### Faker\r\n\r\nYou probably won't want to hardcode strings for your various factories. It would be easier and faster to use random data. TestDummy pulls in the excellent [Faker](https://github.com/fzaninotto/Faker) library to assist with this.\r\n\r\nIn fact, any files in your `tests/factories/` directory will automatically have access to a `$faker` object that you may use. Here's an example:\r\n\r\n```php\r\n$factory('Comment', [\r\n    'body' => $faker->sentence\r\n]);\r\n```\r\n\r\nNow, each time you generate a new comment, the `body` field will be set to a random sentence. Refer to the [Faker](https://github.com/fzaninotto/Faker) documentation for a massive list of available fakes.\r\n\r\n#### Relationships\r\n\r\nIf you wish, TestDummy can automatically generate your relationship models, as well. You just need to let TestDummy know the type of its associated model. TestDummy will then automatically build and save that relationship for you!\r\n\r\nUsing the `Comment` example from above, it stands to reason that a comment belongs to a user, right? Let's set that up:\r\n\r\n```php\r\n$factory('Comment', [\r\n    'user_id' => 'factory:User',\r\n    'body' => $faker->sentence\r\n]);\r\n```\r\n\r\nThat's it! Notice the special syntax here: \"factory:\", followed by the name of the associated class/model.\r\n\r\nTo illustrate this with one more example, if a song belongs to an album, and an album belongs to an artist, then we can easily represent this:\r\n\r\n```php\r\n$factory('App\\Song', [\r\n    'album_id' => 'factory:App\\Album',\r\n    'name' => $faker->sentence\r\n]);\r\n\r\n$factory('App\\Album', [\r\n    'artist_id' => 'factory:App\\Artist',\r\n    'name' => $faker->word\r\n]);\r\n\r\n$factory('App\\Artist', [\r\n    'name' => $faker->word\r\n]);\r\n```\r\n\r\nSo here's the cool thing: this will all work recursively. In translation, if you do...\r\n\r\n```php\r\nuse Laracasts\\TestDummy\\Factory;\r\n\r\n$song = Factory::create('App\\Song');\r\n```\r\n\r\n...then not only will TestDummy build and persist a song to the database, but it'll also do the same for the related album, and its related artist. Nifty!\r\n\r\n#### Custom Factories\r\n\r\nSo far, you've learned how to generate data, using the name of the class, like `App\\User`. However, sometimes, you'll want to define multiple types of users for the purposes of testing.\r\n\r\nWhile it's true that you can use overrides, like this:\r\n\r\n```php\r\nFactory::create('App\\User', ['role' => 'admin']);\r\n```\r\n\r\n...if this is something that you'll be doing often, create a custom factory, like so:\r\n\r\n```php\r\n// A generic factory for users...\r\n\r\n$factory('App\\User', [\r\n    'username' => $faker->username,\r\n    'password' => $faker->password,\r\n    'role'     => 'member'\r\n]);\r\n\r\n// And a custom one for administrators\r\n\r\n$factory('App\\User', 'admin_user', [\r\n    'username' => $faker->username,\r\n    'password' => $faker->password,\r\n    'role'     => 'admin'\r\n]);\r\n```\r\n\r\nIn the code snippet above, you're already familiar with the first example. For the second one, notice that we've added a \"short name\", or identifier for this special type of user factory. Now, whenever you want to quickly generate an admin user, you may do:\r\n\r\n```php\r\nuse Laracasts\\TestDummy\\Factory;\r\n\r\n$adminUser = Factory::create('admin_user');\r\n```\r\n\r\n#### Defining with Closures\r\n\r\nAlternatively, you may pass a closure as the second argument to the `$factory` method. This can be useful for situations where you need a bit more control over the values that you assign to each attribute. Here's an example:\r\n\r\n```php\r\n$factory('App\\Artist', function($faker, $overrides) {\r\n    $name = sprintf('Some Band Named %s', $faker->word);\r\n    \r\n    return [\r\n        'name' => $name\r\n    ];\r\n});\r\n```\r\n\r\nOf course, just be sure to return an array from this closure. If you don't, an exception will be thrown.\r\n\r\n### Step 3: Setup\r\n\r\nWhen testing against a database, it's recommended that each test works with the exact same database environment and structure. That way, you can protect yourself against false positives. An SQLite database (maybe even one in memory) is a good choice in these cases.\r\n\r\n```php\r\npublic function setUp()\r\n{\r\n    parent::setUp();\r\n\r\n    Artisan::call('migrate');\r\n}\r\n```\r\n\r\nOr, if a DB in memory isn't possible, to save a bit of time, a helper `Laracasts\\TestDummy\\DbTestCase` class is included with this package. If you extend it, before each test, your test DB will be migrated (if necessary), and all DB modifications will be channelled through a transaction, and then rolled back on `tearDown`. This will give you a speed boost, and ensure that all tests start with the same database structure.\r\n\r\n```php\r\n\r\nuse Laracasts\\TestDummy\\DbTestCase;\r\n\r\nclass ExampleTest extends DbTestCase {\r\n\r\n    /** @test */\r\n    function it_does_something()\r\n    {\r\n        // Before each test, your database will be rolled back\r\n    }\r\n}\r\n```\r\n\r\n### Step 4: Write Your Tests\r\n\r\nYou're all set to go now. Start testing! Here's some code to get you started. Assuming that you have a `Post` and `Comment` model created...\r\n\r\n```php\r\n\r\nuse Laracasts\\TestDummy\\Factory;\r\n\r\n$comment = Factory::create('Comment');\r\n```\r\n\r\nThis will create and save both a `Comment`, as well as a `Post` record to the database.\r\n\r\nOr, maybe you need to write a test to ensure that, if you have three songs with their respective lengths, when you call a `getTotalLength` method on the owning `Album` model, it will return the correct value. That's easy!\r\n\r\n```php\r\n// create three songs, and explicitly set the length\r\nFactory::times(3)->create('Song', ['length' => 200]);\r\n\r\n$album = Album::first(); // this will be created once automatically.\r\n\r\n$this->assertEquals(600, $album->getTotalLength());\r\n```\r\n\r\nNow, of course, just make sure that you've registered a definition for a `Song` and `Album` in one of your factory files, and you're good to go!\r\n\r\n```\r\n// tests/factories/factories.php\r\n\r\n$factory('Song', [\r\n  'album_id' => 'factory:Album',\r\n  'name' => $faker->sentence\r\n]);\r\n\r\n$factory('Album', [\r\n  'name' => $faker->sentence\r\n]);\r\n```\r\n\r\n### FAQ\r\n\r\n#### How do I specify a different factories folder?\r\n\r\nEasy. Before your tests run, add:\r\n\r\n```\r\nFactory::$factoriesPath = 'app/tests/factories';\r\n```\r\n\r\nNow, TestDummy will look for your registered factories in the `app/tests/factories` folder.\r\n\r\n#### I want to control how my models are built and saved...\r\n\r\nOkay, just create your own implementation of `Laracasts\\TestDummy\\IsPersistable`. This contract is composed of a few methods that you'll need to implement.\r\n\r\nOnce you have your implementation, before your tests run, add:\r\n\r\n```\r\nFactory::$databaseProvider = new MyCustomBuilder;\r\n```\r\n\r\nAnd that's it! Now, whenever you generate and save an entity, TestDummy will reference your custom implementation.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}